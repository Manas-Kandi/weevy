/**
 * Components-Panel.ts - Node Library & Configuration Panel
 * 
 * Provides a library of available nodes and configuration interface
 * for selected nodes. Supports drag-and-drop workflow creation.
 */

import { CanvasNode } from './Canvas';

export interface NodeTemplate {
  type: CanvasNode['type'];
  label: string;
  description: string;
  icon: string;
  color: string;
  category: 'input' | 'processing' | 'output' | 'data';
  defaultConfig: Record<string, any>;
}

export interface ConfigField {
  key: string;
  label: string;
  type: 'text' | 'number' | 'select' | 'boolean' | 'textarea' | 'slider';
  options?: string[] | { label: string; value: any }[];
  min?: number;
  max?: number;
  step?: number;
  default?: any;
  description?: string;
  required?: boolean;
}

export class ComponentsPanel {
  private container: HTMLElement;
  private onNodeDropCallback: (type: CanvasNode['type'], position: { x: number; y: number }) => void;
  private selectedNode: CanvasNode | null = null;
  private isDragging: boolean = false;
  
  // Node templates library
  private nodeTemplates: NodeTemplate[] = [
    {
      type: 'InputNode',
      label: 'Input Node',
      description: 'Receives user input and starts the workflow',
      icon: 'üì•',
      color: '#10b981',
      category: 'input',
      defaultConfig: {
        input_type: 'text',
        validation_rules: [],
        required_fields: [],
        placeholder: 'Enter your input...'
      }
    },
    {
      type: 'BrainNode',
      label: 'Brain Node',
      description: 'Processes information with AI reasoning',
      icon: 'üß†',
      color: '#8b5cf6',
      category: 'processing',
      defaultConfig: {
        personality: 'helpful',
        reasoning_style: 'step_by_step',
        temperature: 0.7,
        max_tokens: 2048,
        custom_instructions: ''
      }
    },
    {
      type: 'KnowledgeBaseNode',
      label: 'Knowledge Base',
      description: 'Searches and retrieves relevant information',
      icon: 'üìö',
      color: '#3b82f6',
      category: 'data',
      defaultConfig: {
        search_type: 'semantic',
        max_results: 5,
        confidence_threshold: 0.7,
        knowledge_source: 'default'
      }
    },
    {
      type: 'OutputNode',
      label: 'Output Node',
      description: 'Formats and presents final results',
      icon: 'üì§',
      color: '#f59e0b',
      category: 'output',
      defaultConfig: {
        output_format: 'text',
        include_metadata: false,
        formatting_style: 'clean'
      }
    }
  ];

  // Configuration field definitions for each node type
  private configFields: Record<CanvasNode['type'], ConfigField[]> = {
    'InputNode': [
      {
        key: 'input_type',
        label: 'Input Type',
        type: 'select',
        options: ['text', 'structured_data', 'file', 'url'],
        default: 'text',
        description: 'Maximum length of AI responses'
      },
      {
        key: 'custom_instructions',
        label: 'Custom Instructions',
        type: 'textarea',
        default: '',
        description: 'Additional instructions for the AI agent'
      }
    ],
    'KnowledgeBaseNode': [
      {
        key: 'search_type',
        label: 'Search Type',
        type: 'select',
        options: [
          { label: 'Semantic Search', value: 'semantic' },
          { label: 'Keyword Search', value: 'keyword' },
          { label: 'Hybrid Search', value: 'hybrid' }
        ],
        default: 'semantic',
        description: 'Type of search to perform',
        required: true
      },
      {
        key: 'max_results',
        label: 'Maximum Results',
        type: 'number',
        min: 1,
        max: 20,
        default: 5,
        description: 'Maximum number of search results to return'
      },
      {
        key: 'confidence_threshold',
        label: 'Confidence Threshold',
        type: 'slider',
        min: 0.1,
        max: 1.0,
        step: 0.1,
        default: 0.7,
        description: 'Minimum confidence score for search results'
      },
      {
        key: 'knowledge_source',
        label: 'Knowledge Source',
        type: 'select',
        options: ['default', 'custom', 'web', 'documents'],
        default: 'default',
        description: 'Source of knowledge to search'
      }
    ],
    'OutputNode': [
      {
        key: 'output_format',
        label: 'Output Format',
        type: 'select',
        options: [
          { label: 'Plain Text', value: 'text' },
          { label: 'Markdown', value: 'markdown' },
          { label: 'JSON', value: 'json' },
          { label: 'HTML', value: 'html' }
        ],
        default: 'text',
        description: 'Format for the final output',
        required: true
      },
      {
        key: 'formatting_style',
        label: 'Formatting Style',
        type: 'select',
        options: [
          { label: 'Clean & Simple', value: 'clean' },
          { label: 'Professional', value: 'professional' },
          { label: 'Detailed', value: 'detailed' }
        ],
        default: 'clean',
        description: 'Style of output formatting'
      },
      {
        key: 'include_metadata',
        label: 'Include Metadata',
        type: 'boolean',
        default: false,
        description: 'Include execution metadata in output'
      }
    ]
  };

  constructor(onNodeDrop: (type: CanvasNode['type'], position: { x: number; y: number }) => void) {
    this.onNodeDropCallback = onNodeDrop;
    this.container = this.createPanelContainer();
    this.initializePanel();
    this.setupEventListeners();
  }

  private createPanelContainer(): HTMLElement {
    const panel = document.createElement('div');
    panel.id = 'components-panel';
    panel.className = 'components-panel';
    panel.style.cssText = `
      position: fixed;
      left: 0;
      top: 0;
      width: 320px;
      height: 100vh;
      background: #ffffff;
      border-right: 1px solid #e5e7eb;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      overflow: hidden;
    `;
    
    document.body.appendChild(panel);
    return panel;
  }

  private initializePanel(): void {
    this.container.innerHTML = `
      <div class="panel-header" style="
        padding: 16px 20px;
        border-bottom: 1px solid #e5e7eb;
        background: #f9fafb;
      ">
        <h2 style="
          margin: 0;
          font-size: 18px;
          font-weight: 600;
          color: #111827;
        ">Components</h2>
        <p style="
          margin: 8px 0 0 0;
          font-size: 14px;
          color: #6b7280;
        ">Drag nodes to the canvas</p>
      </div>
      
      <div class="panel-content" style="
        flex: 1;
        overflow-y: auto;
        padding: 0;
      ">
        <div class="node-library">
          ${this.renderNodeLibrary()}
        </div>
        
        <div class="node-configuration" style="display: none;">
          ${this.renderNodeConfiguration()}
        </div>
      </div>
    `;
  }

  private renderNodeLibrary(): string {
    const categories = this.groupNodesByCategory();
    
    let html = '';
    for (const [category, nodes] of Object.entries(categories)) {
      html += `
        <div class="category-section" style="margin-bottom: 24px;">
          <div class="category-header" style="
            padding: 12px 20px 8px 20px;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
          ">
            ${this.getCategoryLabel(category)}
          </div>
          <div class="category-nodes">
            ${nodes.map(node => this.renderNodeTemplate(node)).join('')}
          </div>
        </div>
      `;
    }
    
    return html;
  }

  private renderNodeTemplate(template: NodeTemplate): string {
    return `
      <div class="node-template" 
           data-node-type="${template.type}"
           draggable="true"
           style="
             display: flex;
             align-items: center;
             padding: 12px 20px;
             cursor: grab;
             border-bottom: 1px solid #f3f4f6;
             transition: all 0.2s ease;
           "
           onmouseover="this.style.backgroundColor='#f9fafb'"
           onmouseout="this.style.backgroundColor='transparent'">
        
        <div class="node-icon" style="
          width: 40px;
          height: 40px;
          border-radius: 8px;
          background: ${template.color};
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 18px;
          margin-right: 12px;
          flex-shrink: 0;
        ">
          ${template.icon}
        </div>
        
        <div class="node-info" style="flex: 1; min-width: 0;">
          <div class="node-label" style="
            font-weight: 500;
            color: #111827;
            margin-bottom: 2px;
            font-size: 14px;
          ">
            ${template.label}
          </div>
          <div class="node-description" style="
            font-size: 12px;
            color: #6b7280;
            line-height: 1.4;
          ">
            ${template.description}
          </div>
        </div>
      </div>
    `;
  }

  private renderNodeConfiguration(): string {
    return `
      <div class="config-header" style="
        padding: 16px 20px;
        border-bottom: 1px solid #e5e7eb;
        background: #f9fafb;
        display: flex;
        align-items: center;
        justify-content: space-between;
      ">
        <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #111827;">
          Node Configuration
        </h3>
        <button id="close-config" style="
          background: none;
          border: none;
          font-size: 18px;
          cursor: pointer;
          color: #6b7280;
          padding: 4px;
        ">√ó</button>
      </div>
      
      <div class="config-content" style="
        padding: 20px;
        overflow-y: auto;
        max-height: calc(100vh - 120px);
      ">
        <div id="config-form">
          <!-- Configuration fields will be dynamically generated here -->
        </div>
        
        <div class="config-actions" style="
          margin-top: 24px;
          padding-top: 16px;
          border-top: 1px solid #e5e7eb;
          display: flex;
          gap: 8px;
        ">
          <button id="save-config" class="btn btn-primary" style="
            flex: 1;
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
          ">
            Save Changes
          </button>
          <button id="reset-config" class="btn btn-secondary" style="
            padding: 8px 16px;
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
          ">
            Reset
          </button>
        </div>
      </div>
    `;
  }

  private setupEventListeners(): void {
    // Drag and drop for node templates
    this.container.addEventListener('dragstart', this.handleDragStart.bind(this));
    this.container.addEventListener('dragend', this.handleDragEnd.bind(this));
    
    // Canvas drop zone (need to set up on canvas container)
    const canvasContainer = document.querySelector('.canvas-container');
    if (canvasContainer) {
      canvasContainer.addEventListener('dragover', this.handleDragOver.bind(this));
      canvasContainer.addEventListener('drop', this.handleDrop.bind(this));
    }
    
    // Configuration panel events
    this.container.addEventListener('click', this.handlePanelClick.bind(this));
    this.container.addEventListener('input', this.handleConfigInput.bind(this));
  }

  private handleDragStart(e: DragEvent): void {
    const target = e.target as HTMLElement;
    const nodeTemplate = target.closest('.node-template') as HTMLElement;
    
    if (nodeTemplate) {
      const nodeType = nodeTemplate.dataset.nodeType as CanvasNode['type'];
      e.dataTransfer?.setData('application/node-type', nodeType);
      
      this.isDragging = true;
      nodeTemplate.style.opacity = '0.5';
      
      // Create drag preview
      const dragPreview = nodeTemplate.cloneNode(true) as HTMLElement;
      dragPreview.style.position = 'absolute';
      dragPreview.style.top = '-1000px';
      dragPreview.style.pointerEvents = 'none';
      document.body.appendChild(dragPreview);
      e.dataTransfer?.setDragImage(dragPreview, 100, 30);
      
      setTimeout(() => document.body.removeChild(dragPreview), 0);
    }
  }

  private handleDragEnd(e: DragEvent): void {
    const target = e.target as HTMLElement;
    const nodeTemplate = target.closest('.node-template') as HTMLElement;
    
    if (nodeTemplate) {
      nodeTemplate.style.opacity = '1';
    }
    
    this.isDragging = false;
  }

  private handleDragOver(e: DragEvent): void {
    e.preventDefault();
    e.dataTransfer!.dropEffect = 'copy';
  }

  private handleDrop(e: DragEvent): void {
    e.preventDefault();
    
    const nodeType = e.dataTransfer?.getData('application/node-type') as CanvasNode['type'];
    if (!nodeType) return;
    
    // Calculate drop position relative to canvas
    const canvasRect = (e.currentTarget as HTMLElement).getBoundingClientRect();
    const position = {
      x: e.clientX - canvasRect.left - 100, // Offset for node center
      y: e.clientY - canvasRect.top - 60
    };
    
    // Call the callback to add the node to canvas
    this.onNodeDropCallback(nodeType, position);
  }

  private handlePanelClick(e: Event): void {
    const target = e.target as HTMLElement;
    
    if (target.id === 'close-config') {
      this.closeNodeConfiguration();
    } else if (target.id === 'save-config') {
      this.saveNodeConfiguration();
    } else if (target.id === 'reset-config') {
      this.resetNodeConfiguration();
    }
  }

  private handleConfigInput(e: Event): void {
    const target = e.target as HTMLInputElement;
    
    if (target.dataset.configKey && this.selectedNode) {
      this.updateNodeConfiguration(target.dataset.configKey, this.getInputValue(target));
    }
  }

  public openNodeConfiguration(node: CanvasNode): void {
    this.selectedNode = node;
    
    // Switch to configuration view
    const library = this.container.querySelector('.node-library') as HTMLElement;
    const config = this.container.querySelector('.node-configuration') as HTMLElement;
    
    library.style.display = 'none';
    config.style.display = 'block';
    
    // Generate configuration form
    this.generateConfigurationForm(node);
  }

  private closeNodeConfiguration(): void {
    this.selectedNode = null;
    
    // Switch back to library view
    const library = this.container.querySelector('.node-library') as HTMLElement;
    const config = this.container.querySelector('.node-configuration') as HTMLElement;
    
    library.style.display = 'block';
    config.style.display = 'none';
  }

  private generateConfigurationForm(node: CanvasNode): void {
    const formContainer = this.container.querySelector('#config-form') as HTMLElement;
    const fields = this.configFields[node.type] || [];
    
    let formHtml = `
      <div class="node-info-header" style="
        display: flex;
        align-items: center;
        margin-bottom: 24px;
        padding: 12px;
        background: ${this.getNodeTemplate(node.type)?.color || '#6b7280'};
        color: white;
        border-radius: 8px;
      ">
        <span style="font-size: 20px; margin-right: 12px;">
          ${this.getNodeTemplate(node.type)?.icon || '‚öôÔ∏è'}
        </span>
        <div>
          <div style="font-weight: 600; margin-bottom: 4px;">
            ${this.getNodeTemplate(node.type)?.label || 'Node Configuration'}
          </div>
          <div style="font-size: 14px; opacity: 0.9;">
            ID: ${node.id}
          </div>
        </div>
      </div>
    `;
    
    fields.forEach(field => {
      formHtml += this.renderConfigField(field, node.data.configuration[field.key]);
    });
    
    formContainer.innerHTML = formHtml;
  }

  private renderConfigField(field: ConfigField, currentValue: any): string {
    const value = currentValue !== undefined ? currentValue : field.default;
    
    let inputHtml = '';
    
    switch (field.type) {
      case 'text':
        inputHtml = `
          <input type="text" 
                 value="${value || ''}" 
                 data-config-key="${field.key}"
                 placeholder="${field.description || ''}"
                 style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px;">
        `;
        break;
        
      case 'number':
        inputHtml = `
          <input type="number" 
                 value="${value || field.default || ''}" 
                 min="${field.min || ''}"
                 max="${field.max || ''}"
                 step="${field.step || 1}"
                 data-config-key="${field.key}"
                 style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px;">
        `;
        break;
        
      case 'select':
        const options = Array.isArray(field.options) ? field.options : [];
        inputHtml = `
          <select data-config-key="${field.key}" 
                  style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px;">
            ${options.map(option => {
              const optionValue = typeof option === 'string' ? option : option.value;
              const optionLabel = typeof option === 'string' ? option : option.label;
              const selected = optionValue === value ? 'selected' : '';
              return `<option value="${optionValue}" ${selected}>${optionLabel}</option>`;
            }).join('')}
          </select>
        `;
        break;
        
      case 'boolean':
        inputHtml = `
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" 
                   ${value ? 'checked' : ''} 
                   data-config-key="${field.key}"
                   style="width: 16px; height: 16px;">
            <span>Enable</span>
          </label>
        `;
        break;
        
      case 'textarea':
        inputHtml = `
          <textarea data-config-key="${field.key}"
                    rows="4"
                    placeholder="${field.description || ''}"
                    style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; resize: vertical;">${value || ''}</textarea>
        `;
        break;
        
      case 'slider':
        inputHtml = `
          <div style="display: flex; align-items: center; gap: 12px;">
            <input type="range" 
                   min="${field.min || 0}"
                   max="${field.max || 100}"
                   step="${field.step || 1}"
                   value="${value || field.default || 0}"
                   data-config-key="${field.key}"
                   style="flex: 1;">
            <span id="slider-value-${field.key}" style="
              min-width: 40px;
              padding: 4px 8px;
              background: #f3f4f6;
              border-radius: 4px;
              font-size: 14px;
              font-weight: 500;
            ">${value || field.default || 0}</span>
          </div>
        `;
        break;
    }
    
    return `
      <div class="config-field" style="margin-bottom: 20px;">
        <label style="
          display: block;
          font-weight: 500;
          color: #374151;
          margin-bottom: 6px;
          font-size: 14px;
        ">
          ${field.label}
          ${field.required ? '<span style="color: #ef4444;">*</span>' : ''}
        </label>
        ${inputHtml}
        ${field.description ? `
          <div style="
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
            line-height: 1.4;
          ">
            ${field.description}
          </div>
        ` : ''}
      </div>
    `;
  }

  private updateNodeConfiguration(key: string, value: any): void {
    if (this.selectedNode) {
      this.selectedNode.data.configuration[key] = value;
      
      // Update slider value display
      const sliderValue = document.getElementById(`slider-value-${key}`);
      if (sliderValue) {
        sliderValue.textContent = value.toString();
      }
    }
  }

  private saveNodeConfiguration(): void {
    if (this.selectedNode) {
      // Validate required fields
      const fields = this.configFields[this.selectedNode.type] || [];
      const requiredFields = fields.filter(f => f.required);
      
      for (const field of requiredFields) {
        if (!this.selectedNode.data.configuration[field.key]) {
          alert(`${field.label} is required`);
          return;
        }
      }
      
      // Update node in canvas (this would trigger a re-render)
      this.updateCanvasNode(this.selectedNode);
      
      // Close configuration panel
      this.closeNodeConfiguration();
    }
  }

  private resetNodeConfiguration(): void {
    if (this.selectedNode) {
      const template = this.getNodeTemplate(this.selectedNode.type);
      if (template) {
        this.selectedNode.data.configuration = { ...template.defaultConfig };
        this.generateConfigurationForm(this.selectedNode);
      }
    }
  }

  private getInputValue(input: HTMLInputElement): any {
    switch (input.type) {
      case 'checkbox':
        return input.checked;
      case 'number':
      case 'range':
        return parseFloat(input.value) || 0;
      default:
        return input.value;
    }
  }

  private groupNodesByCategory(): Record<string, NodeTemplate[]> {
    return this.nodeTemplates.reduce((groups, node) => {
      const category = node.category;
      if (!groups[category]) {
        groups[category] = [];
      }
      groups[category].push(node);
      return groups;
    }, {} as Record<string, NodeTemplate[]>);
  }

  private getCategoryLabel(category: string): string {
    const labels: Record<string, string> = {
      'input': 'Input Nodes',
      'processing': 'Processing Nodes',
      'data': 'Data Nodes',
      'output': 'Output Nodes'
    };
    return labels[category] || category.toUpperCase();
  }

  private getNodeTemplate(type: CanvasNode['type']): NodeTemplate | undefined {
    return this.nodeTemplates.find(t => t.type === type);
  }

  private updateCanvasNode(node: CanvasNode): void {
    // This would typically emit an event or call a callback to update the canvas
    const nodeElement = document.getElementById(`node-${node.id}`);
    if (nodeElement) {
      const configPreview = nodeElement.querySelector('.node-config-preview');
      if (configPreview) {
        configPreview.innerHTML = this.formatConfigPreview(node.data.configuration);
      }
    }
  }

  private formatConfigPreview(config: Record<string, any>): string {
    const keys = Object.keys(config).slice(0, 3);
    return keys.map(key => `${key}: ${JSON.stringify(config[key])}`).join('<br>');
  }

  // Public methods
  public getSelectedNode(): CanvasNode | null {
    return this.selectedNode;
  }

  public refreshNodeLibrary(): void {
    const library = this.container.querySelector('.node-library') as HTMLElement;
    library.innerHTML = this.renderNodeLibrary();
  }
}'Type of input this node accepts',
        required: true
      },
      {
        key: 'placeholder',
        label: 'Placeholder Text',
        type: 'text',
        default: 'Enter your input...',
        description: 'Placeholder text shown to users'
      },
      {
        key: 'validation_rules',
        label: 'Validation Rules',
        type: 'textarea',
        default: '',
        description: 'Custom validation rules (one per line)'
      },
      {
        key: 'required_fields',
        label: 'Required Fields',
        type: 'textarea',
        default: '',
        description: 'List of required fields (one per line)'
      }
    ],
    'BrainNode': [
      {
        key: 'personality',
        label: 'Personality',
        type: 'select',
        options: [
          { label: 'Helpful & Friendly', value: 'helpful' },
          { label: 'Formal & Professional', value: 'formal' },
          { label: 'Creative & Imaginative', value: 'creative' },
          { label: 'Analytical & Precise', value: 'analytical' }
        ],
        default: 'helpful',
        description: 'The AI agent\'s personality style',
        required: true
      },
      {
        key: 'reasoning_style',
        label: 'Reasoning Style',
        type: 'select',
        options: [
          { label: 'Step by Step', value: 'step_by_step' },
          { label: 'Intuitive', value: 'intuitive' },
          { label: 'Data Driven', value: 'data_driven' }
        ],
        default: 'step_by_step',
        description: 'How the AI approaches problem solving'
      },
      {
        key: 'temperature',
        label: 'Creativity Level',
        type: 'slider',
        min: 0.1,
        max: 1.0,
        step: 0.1,
        default: 0.7,
        description: 'Higher values = more creative, lower = more focused'
      },
      {
        key: 'max_tokens',
        label: 'Response Length',
        type: 'select',
        options: [
          { label: 'Brief (512 tokens)', value: 512 },
          { label: 'Standard (2048 tokens)', value: 2048 },
          { label: 'Detailed (4096 tokens)', value: 4096 }
        ],
        default: 2048,
        description: