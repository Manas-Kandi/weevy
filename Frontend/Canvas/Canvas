/**
 * Canvas.ts - Main Canvas Component
 * 
 * The primary workspace where users design AI agent workflows visually.
 * Handles node placement, connections, and real-time collaboration.
 */

import { NodeDesign } from './Node-Design';
import { ComponentsPanel } from './Components-Panel';
import { TestingPanel } from './Testing-Panel';

export interface CanvasNode {
  id: string;
  type: 'BrainNode' | 'InputNode' | 'OutputNode' | 'KnowledgeBaseNode';
  position: { x: number; y: number };
  data: {
    label: string;
    configuration: Record<string, any>;
    systemRules: string;
  };
  connections: {
    inputs: string[];
    outputs: string[];
  };
}

export interface CanvasConnection {
  id: string;
  source: string;
  target: string;
  sourceHandle: string;
  targetHandle: string;
  animated?: boolean;
}

export interface WorkflowExecution {
  id: string;
  status: 'idle' | 'running' | 'completed' | 'error';
  currentNode?: string;
  results: Record<string, any>;
  startTime?: Date;
  endTime?: Date;
}

export class Canvas {
  private container: HTMLElement;
  private nodes: Map<string, CanvasNode> = new Map();
  private connections: Map<string, CanvasConnection> = new Map();
  private selectedNodes: Set<string> = new Set();
  private isDragging: boolean = false;
  private dragOffset: { x: number; y: number } = { x: 0, y: 0 };
  private zoom: number = 1;
  private pan: { x: number; y: number } = { x: 0, y: 0 };
  
  // Component references
  private componentsPanel: ComponentsPanel;
  private testingPanel: TestingPanel;
  
  // WebSocket for real-time execution
  private ws: WebSocket | null = null;
  private currentExecution: WorkflowExecution | null = null;

  constructor(containerId: string) {
    this.container = document.getElementById(containerId)!;
    if (!this.container) {
      throw new Error(`Canvas container with id "${containerId}" not found`);
    }
    
    this.initializeCanvas();
    this.setupEventListeners();
    this.initializeWebSocket();
    
    // Initialize panels
    this.componentsPanel = new ComponentsPanel(this.onNodeDrop.bind(this));
    this.testingPanel = new TestingPanel(this.executeWorkflow.bind(this));
  }

  private initializeCanvas(): void {
    this.container.innerHTML = `
      <div class="canvas-container">
        <!-- Canvas Grid Background -->
        <div class="canvas-grid" style="
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: 
            radial-gradient(circle, #e5e7eb 1px, transparent 1px);
          background-size: 20px 20px;
          background-position: ${this.pan.x}px ${this.pan.y}px;
          opacity: 0.3;
          pointer-events: none;
        "></div>
        
        <!-- Canvas Workspace -->
        <div class="canvas-workspace" style="
          position: relative;
          width: 100%;
          height: 100vh;
          overflow: hidden;
          cursor: grab;
          transform: translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoom});
          transform-origin: 0 0;
        ">
          <!-- Nodes will be dynamically added here -->
        </div>
        
        <!-- Canvas Controls -->
        <div class="canvas-controls" style="
          position: absolute;
          top: 20px;
          right: 20px;
          display: flex;
          gap: 10px;
          z-index: 100;
        ">
          <button id="zoom-in" class="canvas-btn">+</button>
          <button id="zoom-out" class="canvas-btn">-</button>
          <button id="fit-view" class="canvas-btn">⌂</button>
          <button id="execute-workflow" class="canvas-btn primary">▶ Run</button>
        </div>
        
        <!-- Execution Status -->
        <div class="execution-status" style="
          position: absolute;
          bottom: 20px;
          left: 20px;
          padding: 10px 15px;
          background: rgba(0,0,0,0.8);
          color: white;
          border-radius: 6px;
          display: none;
        ">
          <span id="execution-text">Ready</span>
        </div>
      </div>
    `;
  }

  private setupEventListeners(): void {
    const workspace = this.container.querySelector('.canvas-workspace') as HTMLElement;
    
    // Canvas panning
    this.container.addEventListener('mousedown', this.handleCanvasMouseDown.bind(this));
    this.container.addEventListener('mousemove', this.handleCanvasMouseMove.bind(this));
    this.container.addEventListener('mouseup', this.handleCanvasMouseUp.bind(this));
    
    // Zoom controls
    this.container.addEventListener('wheel', this.handleWheel.bind(this));
    document.getElementById('zoom-in')?.addEventListener('click', () => this.setZoom(this.zoom * 1.2));
    document.getElementById('zoom-out')?.addEventListener('click', () => this.setZoom(this.zoom / 1.2));
    document.getElementById('fit-view')?.addEventListener('click', this.fitView.bind(this));
    
    // Workflow execution
    document.getElementById('execute-workflow')?.addEventListener('click', this.executeWorkflow.bind(this));
    
    // Keyboard shortcuts
    document.addEventListener('keydown', this.handleKeyboard.bind(this));
  }

  private initializeWebSocket(url: string = 'ws://localhost:8000/ws/canvas'): void {
    try {
      this.ws = new WebSocket(url);
      
      this.ws.onopen = () => {
        console.log('WebSocket connected to backend');
      };
      
      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleWebSocketMessage(data);
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
      
      this.ws.onclose = () => {
        console.log('WebSocket disconnected');
        // Attempt to reconnect after 3 seconds
        setTimeout(() => this.initializeWebSocket(), 3000);
      };
    } catch (error) {
      console.error('Failed to initialize WebSocket:', error);
    }
  }

  public addNode(type: CanvasNode['type'], position: { x: number; y: number }, config?: any): string {
    const nodeId = `node_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    
    const node: CanvasNode = {
      id: nodeId,
      type,
      position,
      data: {
        label: this.getNodeLabel(type),
        configuration: config || this.getDefaultConfig(type),
        systemRules: this.getSystemRules(type)
      },
      connections: {
        inputs: [],
        outputs: []
      }
    };
    
    this.nodes.set(nodeId, node);
    this.renderNode(node);
    
    return nodeId;
  }

  private renderNode(node: CanvasNode): void {
    const workspace = this.container.querySelector('.canvas-workspace') as HTMLElement;
    
    const nodeElement = document.createElement('div');
    nodeElement.id = `node-${node.id}`;
    nodeElement.className = `canvas-node canvas-node-${node.type.toLowerCase()}`;
    nodeElement.style.cssText = `
      position: absolute;
      left: ${node.position.x}px;
      top: ${node.position.y}px;
      width: 200px;
      min-height: 120px;
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      cursor: move;
      user-select: none;
      transition: all 0.2s ease;
    `;
    
    nodeElement.innerHTML = `
      <div class="node-header" style="
        padding: 12px;
        border-bottom: 1px solid #e5e7eb;
        background: ${this.getNodeColor(node.type)};
        color: white;
        font-weight: 600;
        border-radius: 6px 6px 0 0;
      ">
        <div class="node-type-icon">${this.getNodeIcon(node.type)}</div>
        ${node.data.label}
      </div>
      
      <div class="node-content" style="padding: 12px;">
        <div class="node-config-preview" style="
          font-size: 12px;
          color: #6b7280;
          line-height: 1.4;
        ">
          ${this.formatConfigPreview(node.data.configuration)}
        </div>
      </div>
      
      <div class="node-handles">
        <div class="node-handle input" style="
          position: absolute;
          left: -8px;
          top: 50%;
          width: 16px;
          height: 16px;
          background: #6b7280;
          border-radius: 50%;
          transform: translateY(-50%);
          cursor: crosshair;
        "></div>
        <div class="node-handle output" style="
          position: absolute;
          right: -8px;
          top: 50%;
          width: 16px;
          height: 16px;
          background: #6b7280;
          border-radius: 50%;
          transform: translateY(-50%);
          cursor: crosshair;
        "></div>
      </div>
      
      <!-- Execution Status Indicator -->
      <div class="execution-indicator" style="
        position: absolute;
        top: 8px;
        right: 8px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #d1d5db;
        display: none;
      "></div>
    `;
    
    // Add event listeners for node interaction
    this.setupNodeEventListeners(nodeElement, node);
    
    workspace.appendChild(nodeElement);
  }

  private setupNodeEventListeners(element: HTMLElement, node: CanvasNode): void {
    element.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      this.selectNode(node.id);
      this.isDragging = true;
      this.dragOffset = {
        x: e.clientX - node.position.x,
        y: e.clientY - node.position.y
      };
    });
    
    element.addEventListener('dblclick', () => {
      this.openNodeEditor(node.id);
    });
    
    // Handle connection creation
    const handles = element.querySelectorAll('.node-handle');
    handles.forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        this.startConnection(node.id, handle.classList.contains('output') ? 'output' : 'input');
      });
    });
  }

  public async executeWorkflow(): Promise<void> {
    if (this.nodes.size === 0) {
      alert('Please add some nodes to the workflow first.');
      return;
    }
    
    this.currentExecution = {
      id: `execution_${Date.now()}`,
      status: 'running',
      results: {},
      startTime: new Date()
    };
    
    this.updateExecutionStatus('Running workflow...');
    
    try {
      // Convert canvas nodes to backend format
      const workflowData = this.serializeWorkflow();
      
      // Send to backend via WebSocket
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({
          type: 'execute_workflow',
          data: workflowData
        }));
      } else {
        throw new Error('WebSocket not connected');
      }
      
    } catch (error) {
      console.error('Workflow execution failed:', error);
      this.updateExecutionStatus('Execution failed', 'error');
      this.currentExecution!.status = 'error';
    }
  }

  private serializeWorkflow(): any {
    const nodesArray = Array.from(this.nodes.values());
    const connectionsArray = Array.from(this.connections.values());
    
    return {
      workflow_id: `workflow_${Date.now()}`,
      nodes: nodesArray.map(node => ({
        node_id: node.id,
        node_type: node.type,
        system_rules: node.data.systemRules,
        user_configuration: node.data.configuration,
        position: node.position
      })),
      connections: connectionsArray.map(conn => ({
        source: conn.source,
        target: conn.target,
        type: conn.sourceHandle
      }))
    };
  }

  private handleWebSocketMessage(data: { type: string; node_id?: string; content?: string; result?: any; error?: string }): void {
    if (!data.type) {
      console.error('Invalid WebSocket message: missing type');
      return;
    }
    switch (data.type) {
      case 'execution_update':
        this.handleExecutionUpdate(data);
        break;
      case 'node_result':
        this.handleNodeResult(data);
        break;
      case 'execution_complete':
        this.handleExecutionComplete(data);
        break;
      case 'execution_error':
        this.handleExecutionError(data);
        break;
      default:
        console.warn(`Unknown message type: ${data.type}`);
    }
  }

  private handleExecutionUpdate(data: any): void {
    if (data.node_id) {
      this.highlightExecutingNode(data.node_id);
    }
    if (data.content && this.testingPanel && typeof this.testingPanel.appendStreamContent === 'function') {
      this.testingPanel.appendStreamContent(data.content);
    } else {
      console.warn('appendStreamContent not available or invalid data');
    }
  }

  private handleNodeResult(data: any): void {
    // Stub implementation: log result and update node status
    console.log('Node result received:', data);
    if (data.node_id && data.result) {
      // Update node result in execution data
      if (this.currentExecution) {
        this.currentExecution.results[data.node_id] = data.result;
        this.updateNodeExecutionStatus(data.node_id, 'completed');
      }
    }
  }

  private handleExecutionComplete(data: any): void {
    // Handle workflow completion
    if (this.currentExecution) {
      this.currentExecution.status = 'completed';
      this.currentExecution.endTime = new Date();
      this.updateExecutionStatus('Workflow completed successfully!', 'info');
      // Reset node highlights
      document.querySelectorAll('.node-executing').forEach(el => el.classList.remove('node-executing'));
    }
  }

  private handleExecutionError(data: any): void {
    // Handle workflow error
    if (this.currentExecution) {
      this.currentExecution.status = 'error';
      this.updateExecutionStatus(`Execution error: ${data.error || 'Unknown error'}`, 'error');
    }
  }

  private highlightExecutingNode(nodeId: string): void {
    // Remove previous highlights
    document.querySelectorAll('.node-executing').forEach(el => {
      el.classList.remove('node-executing');
    });
    
    // Highlight current node
    const nodeElement = document.getElementById(`node-${nodeId}`);
    if (nodeElement) {
      nodeElement.classList.add('node-executing');
      
      const indicator = nodeElement.querySelector('.execution-indicator') as HTMLElement;
      if (indicator) {
        indicator.style.display = 'block';
        indicator.style.background = '#f59e0b'; // Orange for executing
        indicator.style.animation = 'pulse 2s infinite';
      }
    }
  }

  // Helper methods for node configuration
  private getNodeLabel(type: CanvasNode['type']): string {
    const labels = {
      'BrainNode': '🧠 Brain Node',
      'InputNode': '📥 Input Node',
      'OutputNode': '📤 Output Node',
      'KnowledgeBaseNode': '📚 Knowledge Base'
    };
    return labels[type];
  }

  private getNodeColor(type: CanvasNode['type']): string {
    const colors = {
      'BrainNode': '#8b5cf6',
      'InputNode': '#10b981',
      'OutputNode': '#f59e0b',
      'KnowledgeBaseNode': '#3b82f6'
    };
    return colors[type];
  }

  private getNodeIcon(type: CanvasNode['type']): string {
    const icons = {
      'BrainNode': '🧠',
      'InputNode': '📥',
      'OutputNode': '📤',
      'KnowledgeBaseNode': '📚'
    };
    return icons[type];
  }

  private getSystemRules(type: CanvasNode['type']): string {
    const rules = {
      'BrainNode': `You are a Brain Node in an AI agent workflow system.
Your job is to:
- Process incoming data using reasoning and intelligence
- Make decisions based on the information provided
- Generate thoughtful responses that guide the workflow
- Always consider context from previous nodes
- Follow the user's configuration preferences`,
      'InputNode': `You are an Input Node in an AI agent workflow system.
Your job is to:
- Receive and validate initial user input
- Format data for downstream processing
- Set the context for the entire workflow
- Ensure data integrity and proper structure`,
      'OutputNode': `You are an Output Node in an AI agent workflow system.
Your job is to:
- Take processed information from previous nodes
- Format it into the final output format requested
- Ensure the output is clean and professional
- Summarize the workflow execution if needed`,
      'KnowledgeBaseNode': `You are a Knowledge Base Node in an AI agent workflow system.
Your job is to:
- Search and retrieve relevant information
- Provide accurate, contextual information
- Format retrieved information clearly
- Indicate confidence levels and sources`
    };
    return rules[type];
  }

  private getDefaultConfig(type: CanvasNode['type']): Record<string, any> {
    const configs = {
      'BrainNode': {
        personality: 'helpful',
        reasoning_style: 'step_by_step',
        temperature: 0.7,
        max_tokens: 2048
      },
      'InputNode': {
        input_type: 'text',
        validation_rules: [],
        required_fields: []
      },
      'OutputNode': {
        output_format: 'text',
        include_metadata: false
      },
      'KnowledgeBaseNode': {
        search_type: 'semantic',
        max_results: 5,
        confidence_threshold: 0.7
      }
    };
    return configs[type];
  }

  private formatConfigPreview(config: Record<string, any>): string {
    const keys = Object.keys(config).slice(0, 3);
    return keys.map(key => `${key}: ${JSON.stringify(config[key])}`).join('<br>');
  }

  // Canvas interaction methods
  private handleCanvasMouseDown(e: MouseEvent): void {
    if ((e.target as HTMLElement).closest('.canvas-node')) return;
    
    this.isDragging = true;
    this.dragOffset = { x: e.clientX - this.pan.x, y: e.clientY - this.pan.y };
    this.container.style.cursor = 'grabbing';
  }

  private handleCanvasMouseMove(e: MouseEvent): void {
    if (!this.isDragging) return;
    
    if (this.selectedNodes.size > 0) {
      // Move selected nodes
      this.selectedNodes.forEach(nodeId => {
        const node = this.nodes.get(nodeId);
        if (node) {
          node.position.x = e.clientX - this.dragOffset.x;
          node.position.y = e.clientY - this.dragOffset.y;
          this.updateNodePosition(nodeId);
        }
      });
    } else {
      // Pan canvas
      this.pan.x = e.clientX - this.dragOffset.x;
      this.pan.y = e.clientY - this.dragOffset.y;
      this.updateCanvasTransform();
    }
  }

  private handleCanvasMouseUp(): void {
    this.isDragging = false;
    this.container.style.cursor = 'grab';
  }

  private handleWheel(e: WheelEvent): void {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    this.setZoom(this.zoom * zoomFactor);
  }

  private setZoom(newZoom: number): void {
    this.zoom = Math.max(0.1, Math.min(3, newZoom));
    this.updateCanvasTransform();
  }

  private updateCanvasTransform(): void {
    const workspace = this.container.querySelector('.canvas-workspace') as HTMLElement;
    workspace.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoom})`;
  }

  private updateNodePosition(nodeId: string): void {
    const node = this.nodes.get(nodeId);
    const element = document.getElementById(`node-${nodeId}`);
    
    if (node && element) {
      element.style.left = `${node.position.x}px`;
      element.style.top = `${node.position.y}px`;
    }
  }

  private updateExecutionStatus(text: string, type: 'info' | 'error' = 'info'): void {
    const statusElement = this.container.querySelector('.execution-status') as HTMLElement;
    const textElement = statusElement.querySelector('#execution-text') as HTMLElement;
    
    textElement.textContent = text;
    statusElement.style.display = 'block';
    statusElement.style.background = type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(0, 0, 0, 0.8)';
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      statusElement.style.display = 'none';
    }, 5000);
  }

  // Event handlers for other methods
  private selectNode(nodeId: string): void {
    this.selectedNodes.clear();
    this.selectedNodes.add(nodeId);
    
    // Update visual selection
    document.querySelectorAll('.canvas-node').forEach(el => el.classList.remove('selected'));
    document.getElementById(`node-${nodeId}`)?.classList.add('selected');
  }

  private openNodeEditor(nodeId: string): void {
    const node = this.nodes.get(nodeId);
    if (node && this.componentsPanel) {
      if (typeof this.componentsPanel.openNodeConfiguration === 'function') {
        this.componentsPanel.openNodeConfiguration(node);
      } else {
        console.error(`openNodeConfiguration not implemented in ComponentsPanel`);
        // Fallback: alert or log error
        alert('Node configuration editor not available.');
      }
    } else {
      console.error('Node or componentsPanel not found');
    }
  }

  private startConnection(nodeId: string, handleType: 'input' | 'output'): void {
    // Simple implementation: create a temporary connection line or log
    console.log(`Connection started from ${nodeId} (${handleType})`);
    // Example: Add a new connection (stub, can be expanded with UI)
    const connectionId = `conn_${Date.now()}`;
    const newConnection: CanvasConnection = {
      id: connectionId,
      source: handleType === 'output' ? nodeId : '', // Set source or target based on handle
      target: handleType === 'input' ? nodeId : '',
      sourceHandle: handleType === 'output' ? 'output' : '',
      targetHandle: handleType === 'input' ? 'input' : '',
    };
    this.connections.set(connectionId, newConnection);
    // Render connection (placeholder)
    this.renderConnection(newConnection);
  }

  private renderConnection(connection: CanvasConnection): void {
    const workspace = this.container.querySelector('.canvas-workspace') as HTMLElement;
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('class', 'connection-line');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    
    const sourceElement = document.getElementById(`node-${connection.source}`);
    const targetElement = document.getElementById(`node-${connection.target}`);
    
    if (sourceElement && targetElement) {
      const sourceRect = sourceElement.getBoundingClientRect();
      const targetRect = targetElement.getBoundingClientRect();
      const workspaceRect = workspace.getBoundingClientRect();
      
      const x1 = sourceRect.left - workspaceRect.left + (connection.sourceHandle === 'output' ? sourceRect.width : 0);
      const y1 = sourceRect.top - workspaceRect.top + sourceRect.height / 2;
      const x2 = targetRect.left - workspaceRect.left + (connection.targetHandle === 'input' ? 0 : targetRect.width);
      const y2 = targetRect.top - workspaceRect.top + targetRect.height / 2;
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', String(x1));
      line.setAttribute('y1', String(y1));
      line.setAttribute('x2', String(x2));
      line.setAttribute('y2', String(y2));
      line.setAttribute('stroke', '#6b7280');
      line.setAttribute('stroke-width', '2');
      
      svg.appendChild(line);
      workspace.appendChild(svg);
    } else {
      console.warn('Connection render failed: source or target node not found');
    }
  }

  private updateNodeExecutionStatus(nodeId: string, status: string): void {
    const nodeElement = document.getElementById(`node-${nodeId}`);
    if (nodeElement) {
      const indicator = nodeElement.querySelector('.execution-indicator') as HTMLElement;
      if (indicator) {
        indicator.style.background = status === 'completed' ? '#10b981' : '#ef4444'; // Green for completed, red for error
      }
    }
  }

  private fitView(): void {
    // Calculate bounds of all nodes and fit view
    if (this.nodes.size === 0) return;
    
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    this.nodes.forEach(node => {
      minX = Math.min(minX, node.position.x);
      minY = Math.min(minY, node.position.y);
      maxX = Math.max(maxX, node.position.x + 200); // Node width
      maxY = Math.max(maxY, node.position.y + 120); // Node height
    });
    
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    const containerRect = this.container.getBoundingClientRect();
    
    this.pan.x = containerRect.width / 2 - centerX;
    this.pan.y = containerRect.height / 2 - centerY;
    
    this.updateCanvasTransform();
  }

  private handleKeyboard(e: KeyboardEvent): void {
    if (e.key === 'Delete' && this.selectedNodes.size > 0) {
      this.selectedNodes.forEach(nodeId => this.deleteNode(nodeId));
      this.selectedNodes.clear();
    }
  }

  private deleteNode(nodeId: string): void {
    this.nodes.delete(nodeId);
    document.getElementById(`node-${nodeId}`)?.remove();
  }

  // Public methods for external access
  public getNodes(): CanvasNode[] {
    return Array.from(this.nodes.values());
  }

  public getConnections(): CanvasConnection[] {
    return Array.from(this.connections.values());
  }

  public clearCanvas(): void {
    this.nodes.clear();
    this.connections.clear();
    this.selectedNodes.clear();
    const workspace = this.container.querySelector('.canvas-workspace');
    if (workspace) {
      workspace.innerHTML = '';
    }
  }

  private onNodeDrop(type: CanvasNode['type'], position: { x: number; y: number }): void {
    this.addNode(type, position);
  }
}