export interface CanvasNode {
    id: string;
    type: 'BrainNode' | 'InputNode' | 'OutputNode' | 'KnowledgeBaseNode';
    position: { x: number; y: number };
    data: {
      label: string;
      configuration: Record<string, any>;
    };
    selected?: boolean;
  }
  
  export interface CanvasConnection {
    id: string;
    source: string;
    target: string;
  }
  
  export class Canvas {
    private container: HTMLElement;
    private nodes: Map<string, CanvasNode> = new Map();
    private connections: Map<string, CanvasConnection> = new Map();
    private selectedNodes: Set<string> = new Set();
    private isDragging: boolean = false;
    private dragOffset: { x: number; y: number } = { x: 0, y: 0 };
    private draggedNodeId: string | null = null;
  
    constructor(containerId: string) {
      const element = document.getElementById(containerId);
      if (!element) {
        throw new Error(`Canvas container with id "${containerId}" not found`);
      }
      this.container = element;
      this.setupEventListeners();
      console.log('Canvas initialized');
    }
  
    private setupEventListeners(): void {
      // Canvas click handling
      this.container.addEventListener('click', (e) => {
        if (e.target === this.container) {
          this.clearSelection();
        }
      });
  
      // Prevent default drag behavior
      this.container.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
  
      // Handle node drops from components panel
      this.container.addEventListener('drop', (e) => {
        e.preventDefault();
        const nodeType = e.dataTransfer?.getData('text/plain');
        if (nodeType) {
          const rect = this.container.getBoundingClientRect();
          const position = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
          };
          this.addNode(nodeType as CanvasNode['type'], position);
        }
      });
    }
  
    public addNode(type: CanvasNode['type'], position: { x: number; y: number }): string {
      const nodeId = `node_${Date.now()}`;
      const node: CanvasNode = {
        id: nodeId,
        type,
        position,
        data: {
          label: this.getNodeLabel(type),
          configuration: {}
        },
        selected: false
      };
  
      this.nodes.set(nodeId, node);
      this.renderNode(node);
      console.log(`Added ${type} node at`, position);
      return nodeId;
    }
  
    private getNodeLabel(type: CanvasNode['type']): string {
      const labels = {
        'BrainNode': 'AI Brain',
        'InputNode': 'Input',
        'OutputNode': 'Output',
        'KnowledgeBaseNode': 'Knowledge Base'
      };
      return labels[type] || type;
    }
  
    private getNodeIcon(type: CanvasNode['type']): string {
      const icons = {
        'BrainNode': 'üß†',
        'InputNode': 'üì•',
        'OutputNode': 'üì§',
        'KnowledgeBaseNode': 'üìö'
      };
      return icons[type] || '‚öôÔ∏è';
    }
  
    private getNodeColor(type: CanvasNode['type']): string {
      const colors = {
        'BrainNode': '#8b5cf6',
        'InputNode': '#10b981',
        'OutputNode': '#f59e0b',
        'KnowledgeBaseNode': '#3b82f6'
      };
      return colors[type] || '#6b7280';
    }
  
    private renderNode(node: CanvasNode): void {
      const nodeElement = document.createElement('div');
      nodeElement.id = `node-${node.id}`;
      nodeElement.className = `canvas-node ${node.selected ? 'selected' : ''}`;
      nodeElement.style.left = `${node.position.x}px`;
      nodeElement.style.top = `${node.position.y}px`;
  
      nodeElement.innerHTML = `
        <div class="node-header">
          <div class="node-icon" style="background: ${this.getNodeColor(node.type)}; color: white;">
            ${this.getNodeIcon(node.type)}
          </div>
          <span class="node-title">${node.data.label}</span>
          <span class="node-type">${node.type}</span>
        </div>
        <div class="connection-handle handle-input" data-handle="input"></div>
        <div class="connection-handle handle-output" data-handle="output"></div>
      `;
  
      // Add event listeners
      nodeElement.addEventListener('click', (e) => {
        e.stopPropagation();
        this.selectNode(node.id);
      });
  
      nodeElement.addEventListener('mousedown', (e) => {
        if (e.button === 0) { // Left mouse button
          this.startDrag(node.id, e);
        }
      });
  
      nodeElement.addEventListener('dblclick', () => {
        this.openNodeConfiguration(node.id);
      });
  
      this.container.appendChild(nodeElement);
    }
  
    private startDrag(nodeId: string, e: MouseEvent): void {
      const node = this.nodes.get(nodeId);
      if (!node) return;
  
      this.isDragging = true;
      this.draggedNodeId = nodeId;
      this.dragOffset = {
        x: e.clientX - node.position.x,
        y: e.clientY - node.position.y
      };
  
      const handleMouseMove = (e: MouseEvent) => {
        if (this.isDragging && this.draggedNodeId) {
          this.updateNodePosition(this.draggedNodeId, {
            x: e.clientX - this.dragOffset.x,
            y: e.clientY - this.dragOffset.y
          });
        }
      };
  
      const handleMouseUp = () => {
        this.isDragging = false;
        this.draggedNodeId = null;
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
  
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }
  
    private updateNodePosition(nodeId: string, position: { x: number; y: number }): void {
      const node = this.nodes.get(nodeId);
      if (!node) return;
  
      node.position = position;
      const element = document.getElementById(`node-${nodeId}`);
      if (element) {
        element.style.left = `${position.x}px`;
        element.style.top = `${position.y}px`;
      }
    }
  
    private selectNode(nodeId: string): void {
      // Clear previous selection
      this.clearSelection();
      
      // Select new node
      this.selectedNodes.add(nodeId);
      const node = this.nodes.get(nodeId);
      if (node) {
        node.selected = true;
        const element = document.getElementById(`node-${nodeId}`);
        if (element) {
          element.classList.add('selected');
        }
      }
    }
  
    private clearSelection(): void {
      this.selectedNodes.forEach(nodeId => {
        const node = this.nodes.get(nodeId);
        if (node) {
          node.selected = false;
          const element = document.getElementById(`node-${nodeId}`);
          if (element) {
            element.classList.remove('selected');
          }
        }
      });
      this.selectedNodes.clear();
    }
  
    private openNodeConfiguration(nodeId: string): void {
      console.log(`Opening configuration for node ${nodeId}`);
      // This will be implemented when we create the Components Panel
    }
  
    public deleteSelectedNodes(): void {
      this.selectedNodes.forEach(nodeId => {
        this.deleteNode(nodeId);
      });
      this.selectedNodes.clear();
    }
  
    private deleteNode(nodeId: string): void {
      // Remove from DOM
      const element = document.getElementById(`node-${nodeId}`);
      if (element) {
        element.remove();
      }
  
      // Remove from data structures
      this.nodes.delete(nodeId);
      
      // Remove any connections to this node
      this.connections.forEach((connection, connId) => {
        if (connection.source === nodeId || connection.target === nodeId) {
          this.connections.delete(connId);
        }
      });
    }
  
    public getNodes(): CanvasNode[] {
      return Array.from(this.nodes.values());
    }
  
    public getSelectedNodes(): CanvasNode[] {
      return Array.from(this.selectedNodes)
        .map(id => this.nodes.get(id))
        .filter((node): node is CanvasNode => node !== undefined);
    }
  
    public clearCanvas(): void {
      this.container.innerHTML = '';
      this.nodes.clear();
      this.connections.clear();
      this.selectedNodes.clear();
      console.log('Canvas cleared');
    }
  }